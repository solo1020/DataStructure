# DataStrucure

#### Java 内存基础
> Java内存占用(字节)：
   * byte:1
   * short:2
   * int:4
   * long:8
   * float:4
   * double:8
   * boolean:1
   * char:2
   * 一个对象引用：8
   * 对象本身(除去对象内部存储的信息占用):16 保存对象头信息
   * 内存使用不够8字节 自动填充为8字节
   * 原始数据类型数组:24 (16字节为对象本身开销 + 4字节保存长度 + 4填充字节)

<hr>


## 排序
### 冒泡排序
> 冒泡排序：  
每一轮找出 待比较元素组  中的 最大值放到该元素组最末尾   
具体实现：  
顾名思义，冒泡一样的一个个往上  
即 相邻的两个比较，将较大的一个放到后面 一直重复到完成该轮比较  
同时，待比较元素组 每轮都在变化  
因为 第一轮已经找到了原始数组中的最大值，不需要再进行比较  
所以 每一轮的 待比较数组为 0索引 到 (原始数组末尾索引 减 第几轮)  

#####关键字：相邻两两比较将较大值往后冒泡

<hr>

时间复杂度分析：  
> 冒泡排序时间复杂度分析：  
外层循环是比较的元素的个数 从数组长度一直变到0 在n 也就是n次  
内层循环对每个子序列进行交换 也就是每两两交换，在最坏情况，即 数组长度n - 1 次  
其中的 交换代码的复杂度 可以看作1  
所以总复杂度为 O(n^2)  

### 选择排序
> 选择排序：    
选择排序每一轮是将待比较序列中第一个元素视为最小，并记录最小值的索引值  
然后依次进行比较，如果序列剩下部分比 认定的 最小元素还小，记录更新这个新的最小元素的索引值  
在本轮查找结束前交换 原先认定的最小值和 实际的最小值  
重复以上知道最后一个元素  

##### 关键字： 记录最小索引

<hr>

时间复杂度分析：
> 选择排序时间复杂度分析：  
外层是循环数据量或者循环轮数 也就是 n  
内层是比较，关键在于，内层循环只进行赋值，比冒泡排序的交换少了一步 也趋近于n  
然后交换次数为 元素个数  
容易看出时间复杂度也是O(n^2)  