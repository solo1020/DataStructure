# DataStrucure

#### Java 内存基础
> Java内存占用(字节)：
   * byte:1
   * short:2
   * int:4
   * long:8
   * float:4
   * double:8
   * boolean:1
   * char:2
   * 一个对象引用：8
   * 对象本身(除去对象内部存储的信息占用):16 保存对象头信息
   * 内存使用不够8字节 自动填充为8字节
   * 原始数据类型数组:24 (16字节为对象本身开销 + 4字节保存长度 + 4填充字节)

<hr>


## 排序
### 冒泡排序
> 冒泡排序：  
每一轮找出 待比较元素组  中的 最大值放到该元素组最末尾   
具体实现：  
顾名思义，冒泡一样的一个个往上  
即 相邻的两个比较，将较大的一个放到后面 一直重复到完成该轮比较  
同时，待比较元素组 每轮都在变化  
因为 第一轮已经找到了原始数组中的最大值，不需要再进行比较  
所以 每一轮的 待比较数组为 0索引 到 (原始数组末尾索引 减 第几轮)  

##### 关键字：相邻两两比较将较大值往后冒泡

时间复杂度分析：  
> 冒泡排序时间复杂度分析：  
外层循环是比较的元素的个数 从数组长度一直变到0 在n 也就是n次  
内层循环对每个子序列进行交换 也就是每两两交换，在最坏情况，即 数组长度n - 1 次  
其中的 交换代码的复杂度 可以看作1  
所以总复杂度为 O(n^2)  

<hr>

### 选择排序
> 选择排序：    
选择排序每一轮是将待比较序列中第一个元素视为最小，并记录最小值的索引值  
然后依次进行比较，如果序列剩下部分比 认定的 最小元素还小，记录更新这个新的最小元素的索引值  
在本轮查找结束前交换 原先认定的最小值和 实际的最小值  
重复以上知道最后一个元素  

##### 关键字： 记录最小索引

时间复杂度分析：
> 选择排序时间复杂度分析：  
外层是循环数据量或者循环轮数 也就是 n  
内层是比较，关键在于，内层循环只进行赋值，比冒泡排序的交换少了一步 也趋近于n  
然后交换次数为 元素个数  
容易看出时间复杂度也是O(n^2)  

<hr>

### 插入排序
> 插入排序：  
将数组视为两部分，其中一部分为已排序数组(起始认定0索引元素为已排序)，另一部分为未排序的元素序列  
然后从未排序的序列中的第一个元素  
按倒序与已排序的数组进行遍历 比较    
如果已排序数组中的元素比 该未排序序列第一个元素 大， 则进行交换 因为大的要往后放  
一直到已排序数组中的某个元素比 该未排序序列第一个元素小 则停止本轮查找  
如果一直到0索引都没有元素比 该元素小 那该元素就是最小的   
同时也说明 已排序数组中所有元素都比该元素大    
在查找的过程中已经一一进行了交换  

##### 关键点：
关键在于未排序数组元素的第一个元素 与前面已排序数组的比较  
也就是 j 索引和 j-1 位置元素的比较  
一开始的想法是 直接找到比该元素小的位置进行插入，结果发现交换之后 已排序数组的排序也打乱了  
所以 不能用 i 位置 去和已排序数组进行遍历比较   
因为数组已经排序了，所以只要找到第一次 发现 已排序数组中元素比 待排序元素小 则说明已经为其找到了正确的位置   
而在这个过程中，因为是从后往前遍历，必定所有的元素都比其大   
所以对每一个比其大的都进行交换即可  保持已排序数组的 排序阵型   
而待排序元素 j 在与前一个比它大的 j-1 交换之后 j--   
进入下一次内循环， 此时再比较新的 j(也是刚才交换前的j的值) 与 新的 j-1 的值   
这个过程也可以看成一个冒泡排序   

时间复杂度分析：容易看出也是两层关于n的循环 所以为 O(n^2)

```
// 冒泡排序
for( int i = 0; i < arr.length - 1; i++){
    for( int j = 0; j < arr.length - 1 - i; j++){
        if(arr[j] > arr[j+1]){
            // exchange
        }
    } 

}

```


### leetcode 1047
思路其实很简单 或者说很容易想到：  
最开始的就是想 i索引和 i+1 位置进行比较 然后进一步处理 不管是截取出来还是什么也好  
但是这里有一个问题 要确保i+1 也不会越界 所以只能在for循环中判断 i<s.length()-1   
而坑就在这里 因为两个位置的字符比较 我这的处理是直接 i+=1 的 导致 就是最后一个元素没法获取到  

最后想起来  
我干嘛要死盯着这一个字符串  
我给他复制一个相同的 然后往前挪一个位置  
使得 **newStr = s.substring(1)+" " ** 最后一位加上一个空白字符 确保能够与原字符一一对应进行比较    
然后在这里 的i 就可以一直从0 循环到 s.length()了  